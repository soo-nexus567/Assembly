     1                                  ;======================================================================|  
     2                                  ; Copyright Info                                                       |  
     3                                  ; "Assignment 3" is free software: you can redistribute it and modify  |  
     4                                  ; it under the terms of the GNU General Public License as published by |  
     5                                  ; the Free Software Foundation, either version 3 of the License, or    |  
     6                                  ; (at your option) any later version.                                  |  
     7                                  ;                                                                      |  
     8                                  ; "Assignment 3" is distributed in the hope that it will be useful,    |  
     9                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of       |  
    10                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU     |  
    11                                  ; General Public License for more details.                             |  
    12                                  ;                                                                      |  
    13                                  ; You should have received a copy of the GNU General Public License    |  
    14                                  ; along with this program. If not, see <https://www.gnu.org/licenses/>.|  
    15                                  ;======================================================================|  
    16                                  ; Author information                                                   |  
    17                                  ; Author Name    : Jonathan Soo                                        |  
    18                                  ; Author Email   : jonathansoo07@csu.fullerton.edu                     |  
    19                                  ; Author Section : 240-11                                              |  
    20                                  ; Author CWID    : 884776980                                           |  
    21                                  ;======================================================================|  
    22                                  ; Purpose                                                              |  
    23                                  ; Calculate the third side of a triangle using floating-point          |  
    24                                  ; arithmetic. Get input from user and output using C functions.        |  
    25                                  ;======================================================================|  
    26                                  ; Program information                                                  |  
    27                                  ; Program Name      : Assignment 3                                     |  
    28                                  ; Copyright (C)     : 2025, Jonathan Soo                               |  
    29                                  ; Programming Lang. : One module in C and one in x86-64                |  
    30                                  ; Date program began: 2025-Mar-05                                      |  
    31                                  ; Date program completed: 2025-Mar-08                                  |  
    32                                  ; Date comments upgraded: 2025-Mar-08                                  |  
    33                                  ; Files in this program: huron.asm, istriangle.asm, manager.asm,       |  
    34                                  ;                        main.c, r.sh                                  |  
    35                                  ; Status: Complete. No errors found after testing.                     |  
    36                                  ;======================================================================|  
    37                                  ; This file                                                            |  
    38                                  ; File Name  : manager.asm                                             |  
    39                                  ; Language   : x86-64                                                  |  
    40                                  ; Assemble   : nasm -f elf64 -o manager.o manager.asm                  |  
    41                                  ; Editor     : VS Code                                                 |  
    42                                  ; Link       : gcc -m64 -no-pie -o learn.out manager.o huron.o         |  
    43                                  ;              istriangle.o main.o -std=c2x -Wall -z noexecstack -lm   |  
    44                                  ;======================================================================|  
    45                                  global manager
    46                                  
    47                                      extern scanf
    48                                      extern printf
    49                                      extern atof
    50                                      extern huron
    51                                      extern istriangle
    52                                      extern stdin
    53                                      extern fgets
    54                                      extern strlen
    55                                  array_size equ 12
    56                                  null equ 0
    57                                  true equ -1
    58                                  false equ 0
    59                                  
    60                                  segment .data
    61 00000000 506C6561736520656E-         prompt_input db "Please enter the lengths of three sides of a triangle:", 10, 0
    61 00000009 74657220746865206C-
    61 00000012 656E67746873206F66-
    61 0000001B 207468726565207369-
    61 00000024 646573206F66206120-
    61 0000002D 747269616E676C653A-
    61 00000036 0A00               
    62 00000038 546865736520696E70-         valid_input db "These inputs have been tested and they are sides of a valid triangle.", 10, 10,  0
    62 00000041 757473206861766520-
    62 0000004A 6265656E2074657374-
    62 00000053 656420616E64207468-
    62 0000005C 657920617265207369-
    62 00000065 646573206F66206120-
    62 0000006E 76616C696420747269-
    62 00000077 616E676C652E0A0A00 
    63 00000080 546865204875726F6E-         huron_applied db "The Huron formula will be applied to find the area.", 10, 10, 0
    63 00000089 20666F726D756C6120-
    63 00000092 77696C6C2062652061-
    63 0000009B 70706C69656420746F-
    63 000000A4 2066696E6420746865-
    63 000000AD 20617265612E0A0A00 
    64 000000B6 546865206172656120-         huron_area db "The area is %.2f sq units. This number will be returned to the caller module.", 10, 10, 0
    64 000000BF 697320252E32662073-
    64 000000C8 7120756E6974732E20-
    64 000000D1 54686973206E756D62-
    64 000000DA 65722077696C6C2062-
    64 000000E3 652072657475726E65-
    64 000000EC 6420746F2074686520-
    64 000000F5 63616C6C6572206D6F-
    64 000000FE 64756C652E0A0A00   
    65 00000106 257300                      format_string db "%s", 0
    66 00000109 256600                      format_string1 db "%f", 0
    67 0000010C 4572726F7220696E70-         prompt_tryagain db "Error input try again", 10, 0
    67 00000115 757420747279206167-
    67 0000011E 61696E0A00         
    68 00000123 546865736520696E70-         three_inputs db "These inputs have been tested and they are not the sides of a valid triangle.", 10,10, 0
    68 0000012C 757473206861766520-
    68 00000135 6265656E2074657374-
    68 0000013E 656420616E64207468-
    68 00000147 657920617265206E6F-
    68 00000150 742074686520736964-
    68 00000159 6573206F6620612076-
    68 00000162 616C69642074726961-
    68 0000016B 6E676C652E0A0A00   
    69 00000173 546865736520696E70-         invalid db "These inputs have been tested and they are not the sides of a valid triangle.", 10,10, 0
    69 0000017C 757473206861766520-
    69 00000185 6265656E2074657374-
    69 0000018E 656420616E64207468-
    69 00000197 657920617265206E6F-
    69 000001A0 742074686520736964-
    69 000001A9 6573206F6620612076-
    69 000001B2 616C69642074726961-
    69 000001BB 6E676C652E0A0A00   
    70 000001C3 5468616E6B20796F75-         thank_you db "Thank you", 10,10,  0
    70 000001CC 0A0A00             
    71 000001CF 0000000000000000            results dq 0.0
    72 000001D7 000000000000F0BF            negative_one dq -1.0
    73                                  segment .bss
    74                                      align 64
    75 00000000 <res 340h>                  storedata resb 832
    76 00000340 <res 60h>                   nice_array resq array_size
    77 000003A0 ????????????????            side_a resq 1
    78 000003A8 ????????????????            side_b resq 1
    79 000003B0 ????????????????            side_c resq 1
    80 000003B8 ????????????????            area resq 1
    81                                  segment .text
    82                                      %include "triangle.inc"
    83                              <1> 
    84                              <1> 
    85 00000000 0A546869732070726F- <1> array_line1 db 10, "This program is brought to you as a courtesy of", 10, "Author: Jonathan Soo", 10, "CWID: 884776980", 10, "Email: jonathansoo07@csu.fullerton.edu", 10, 10,  0
    85 00000009 6772616D2069732062- <1>
    85 00000012 726F7567687420746F- <1>
    85 0000001B 20796F752061732061- <1>
    85 00000024 20636F757274657379- <1>
    85 0000002D 206F660A417574686F- <1>
    85 00000036 723A204A6F6E617468- <1>
    85 0000003F 616E20536F6F0A4357- <1>
    85 00000048 49443A203838343737- <1>
    85 00000051 363938300A456D6169- <1>
    85 0000005A 6C3A206A6F6E617468- <1>
    85 00000063 616E736F6F30374063- <1>
    85 0000006C 73752E66756C6C6572- <1>
    85 00000075 746F6E2E6564750A0A- <1>
    85 0000007E 00                  <1>
    86                              <1> %macro back_register 0    ;ar = activation record
    87                              <1>     push    rbp
    88                              <1>     mov     rbp, rsp
    89                              <1> 
    90                              <1>     ; Save the general purpose registers
    91                              <1>     push    rbx
    92                              <1>     push    rcx
    93                              <1>     push    rdx
    94                              <1>     push    rsi
    95                              <1>     push    rdi
    96                              <1>     push    r8 
    97                              <1>     push    r9 
    98                              <1>     push    r10
    99                              <1>     push    r11
   100                              <1>     push    r12
   101                              <1>     push    r13
   102                              <1>     push    r14
   103                              <1>     push    r15
   104                              <1>     pushf
   105                              <1> %endmacro
   106                              <1> %macro backup_compnents 1
   107                              <1> ;This macro backs up all registers except GPRs to an array specified in parameter %1
   108                              <1>    mov rax,7
   109                              <1>    mov rdx,0
   110                              <1>    xsave [%1]
   111                              <1> %endmacro
   112                              <1> %macro restore_components 1
   113                              <1>    mov rax,7
   114                              <1>    mov rdx,0
   115                              <1>    xrstor [%1]
   116                              <1> %endmacro
   117                              <1> %macro print_info 0
   118                              <1>     mov rax, 0
   119                              <1>     mov rdi, array_line1
   120                              <1>     call printf
   121                              <1> %endmacro
   122                              <1> %macro restore_registers 0
   123                              <1>     popf          
   124                              <1>     pop     r15
   125                              <1>     pop     r14
   126                              <1>     pop     r13
   127                              <1>     pop     r12
   128                              <1>     pop     r11
   129                              <1>     pop     r10
   130                              <1>     pop     r9 
   131                              <1>     pop     r8 
   132                              <1>     pop     rdi
   133                              <1>     pop     rsi
   134                              <1>     pop     rdx
   135                              <1>     pop     rcx
   136                              <1>     pop     rbx
   137                              <1> 
   138                              <1>     ; Restore the base pointer
   139                              <1>     pop     rbp
   140                              <1> %endmacro
    83                                  manager:
    84                                      ; ┌────────────────────────────────────────────────────────┐
    85                                      ; │ Back up General Purpose Registers (GPRs)               │
    86                                      ; └────────────────────────────────────────────────────────┘
    87                                      back_register
    87 0000007F 55                  <1>  push rbp
    88 00000080 4889E5              <1>  mov rbp, rsp
    89                              <1> 
    90                              <1> 
    91 00000083 53                  <1>  push rbx
    92 00000084 51                  <1>  push rcx
    93 00000085 52                  <1>  push rdx
    94 00000086 56                  <1>  push rsi
    95 00000087 57                  <1>  push rdi
    96 00000088 4150                <1>  push r8
    97 0000008A 4151                <1>  push r9
    98 0000008C 4152                <1>  push r10
    99 0000008E 4153                <1>  push r11
   100 00000090 4154                <1>  push r12
   101 00000092 4155                <1>  push r13
   102 00000094 4156                <1>  push r14
   103 00000096 4157                <1>  push r15
   104 00000098 9C                  <1>  pushf
    88                                  
    89                                      ; ┌────────────────────────────────────────────────────────┐
    90                                      ; │ Save all the floating-point numbers and print info     │
    91                                      ; └────────────────────────────────────────────────────────┘
    92                                      backup_compnents storedata
   107                              <1> 
   108 00000099 B807000000          <1>  mov rax,7
   109 0000009E BA00000000          <1>  mov rdx,0
   110 000000A3 0FAE2425[00000000]  <1>  xsave [%1]
    93                                      print_info
   118 000000AB B800000000          <1>  mov rax, 0
   119 000000B0 48BF-               <1>  mov rdi, array_line1
   119 000000B2 [0000000000000000]  <1>
   120 000000BA E8(00000000)        <1>  call printf
    94                                  
    95                                      ; ┌────────────────────────────────────────────────────────┐
    96                                      ; │ Prompt the input instruction                           │
    97                                      ; └────────────────────────────────────────────────────────┘
    98 000000BF B800000000                  mov     rax, 0
    99 000000C4 48BF-                       mov     rdi, prompt_input
    99 000000C6 [0000000000000000] 
   100 000000CE E8(00000000)                call    printf
   101                                  
   102                                      ; ┌────────────────────────────────────────────────────────┐
   103                                      ; │ Give the inputs to input_array where they are stored   │
   104                                      ; │ in an array (nice_array)                               │
   105                                      ; └────────────────────────────────────────────────────────┘
   106 000000D3 48BF-                       mov     rdi, nice_array
   106 000000D5 [4003000000000000] 
   107 000000DD BE0C000000                  mov     rsi, array_size
   108 000000E2 E84B010000                  call    input_array
   109 000000E7 4989C7                      mov     r15, rax
   110                                  
   111                                      ; ┌────────────────────────────────────────────────────────┐
   112                                      ; │ Check if there are 3 inputs                            │
   113                                      ; │ If not, exit and prompt user to re-run the program     │
   114                                      ; └────────────────────────────────────────────────────────┘
   115 000000EA 4983FF03                    cmp     r15, 3
   116 000000EE 0F8F2C020000                jg      no_triangle
   117                                      
   118                                      ; ┌────────────────────────────────────────────────────────┐
   119                                      ; │ Store the elements of the array in separate variables  │
   120                                      ; └────────────────────────────────────────────────────────┘
   121 000000F4 F2440F103C25-               movsd   xmm15, [nice_array]  
   121 000000FA [40030000]         
   122 000000FE F2440F113C25-               movsd   [side_a], xmm15   
   122 00000104 [A0030000]         
   123                                  
   124 00000108 F2440F103425-               movsd   xmm14, [nice_array+8]  
   124 0000010E [48030000]         
   125 00000112 F2440F113425-               movsd   [side_b], xmm14   
   125 00000118 [A8030000]         
   126                                  
   127 0000011C F2440F102C25-               movsd   xmm13, [nice_array+16]  
   127 00000122 [50030000]         
   128 00000126 F2440F112C25-               movsd   [side_c], xmm13   
   128 0000012C [B0030000]         
   129                                  
   130                                      ; ┌────────────────────────────────────────────────────────┐
   131                                      ; │ Print thank you message                                │
   132                                      ; └────────────────────────────────────────────────────────┘
   133 00000130 B800000000                  mov     rax, 0
   134 00000135 48BF-                       mov     rdi, thank_you
   134 00000137 [C301000000000000] 
   135 0000013F E8(00000000)                call    printf
   136                                      
   137                                      ; ┌────────────────────────────────────────────────────────┐
   138                                      ; │ Validate the sides given using istriangle              │
   139                                      ; └────────────────────────────────────────────────────────┘
   140 00000144 48BF-                       mov     rdi, side_a
   140 00000146 [A003000000000000] 
   141 0000014E 48BE-                       mov     rsi, side_b
   141 00000150 [A803000000000000] 
   142 00000158 48BA-                       mov     rdx, side_c
   142 0000015A [B003000000000000] 
   143 00000162 E8(00000000)                call    istriangle
   144                                  
   145                                      ; ┌────────────────────────────────────────────────────────┐
   146                                      ; │ If istriangle returns -1, exit the program             │
   147                                      ; └────────────────────────────────────────────────────────┘
   148 00000167 4883F8FF                    cmp     rax, -1
   149 0000016B 0F84AF010000                je      no_triangle
   150                                      
   151                                      ; ┌────────────────────────────────────────────────────────┐
   152                                      ; │ Print valid input message                              │
   153                                      ; └────────────────────────────────────────────────────────┘
   154 00000171 B800000000                  mov     rax, 0
   155 00000176 48BF-                       mov     rdi, valid_input
   155 00000178 [3800000000000000] 
   156 00000180 E8(00000000)                call    printf
   157                                  
   158                                      ; ┌────────────────────────────────────────────────────────┐
   159                                      ; │ Notify user that Heron's formula will be applied       │
   160                                      ; └────────────────────────────────────────────────────────┘
   161 00000185 B800000000                  mov     rax, 0
   162 0000018A 48BF-                       mov     rdi, huron_applied
   162 0000018C [8000000000000000] 
   163 00000194 E8(00000000)                call    printf
   164                                  
   165                                      ; ┌────────────────────────────────────────────────────────┐
   166                                      ; │ Give validated inputs to huron to calculate area       │
   167                                      ; └────────────────────────────────────────────────────────┘
   168 00000199 48BF-                       mov     rdi, side_a
   168 0000019B [A003000000000000] 
   169 000001A3 48BE-                       mov     rsi, side_b
   169 000001A5 [A803000000000000] 
   170 000001AD 48BA-                       mov     rdx, side_c
   170 000001AF [B003000000000000] 
   171 000001B7 E8(00000000)                call    huron
   172 000001BC F20F110425-                 movsd   [area], xmm0
   172 000001C1 [B8030000]         
   173                                  
   174                                      ; ┌────────────────────────────────────────────────────────┐
   175                                      ; │ Print the calculated area from huron function          │
   176                                      ; └────────────────────────────────────────────────────────┘
   177 000001C5 48BF-                       mov     rdi, huron_area  
   177 000001C7 [B600000000000000] 
   178 000001CF 48BE-                       mov     rsi, area 
   178 000001D1 [B803000000000000] 
   179 000001D9 B801000000                  mov     rax, 1                   
   180 000001DE E8(00000000)                call    printf 
   181                                  
   182                                      ; ┌────────────────────────────────────────────────────────┐
   183                                      ; │ Restore floating-point numbers                         │
   184                                      ; └────────────────────────────────────────────────────────┘
   185                                      restore_components storedata
   113 000001E3 B807000000          <1>  mov rax,7
   114 000001E8 BA00000000          <1>  mov rdx,0
   115 000001ED 0FAE2C25[00000000]  <1>  xrstor [%1]
   186 000001F5 4C89F8                      mov     rax, r15
   187 000001F8 F20F100425-                 movsd   xmm0, [area]
   187 000001FD [B8030000]         
   188                                  
   189                                      ; ┌────────────────────────────────────────────────────────┐
   190                                      ; │ Restore GPRs and return                                │
   191                                      ; └────────────────────────────────────────────────────────┘
   192                                      restore_registers
   123 00000201 9D                  <1>  popf
   124 00000202 415F                <1>  pop r15
   125 00000204 415E                <1>  pop r14
   126 00000206 415D                <1>  pop r13
   127 00000208 415C                <1>  pop r12
   128 0000020A 415B                <1>  pop r11
   129 0000020C 415A                <1>  pop r10
   130 0000020E 4159                <1>  pop r9
   131 00000210 4158                <1>  pop r8
   132 00000212 5F                  <1>  pop rdi
   133 00000213 5E                  <1>  pop rsi
   134 00000214 5A                  <1>  pop rdx
   135 00000215 59                  <1>  pop rcx
   136 00000216 5B                  <1>  pop rbx
   137                              <1> 
   138                              <1> 
   139 00000217 5D                  <1>  pop rbp
   193 00000218 C3                          ret
   194                                  
   195                                  ; ┌────────────────────────────────────────────────────────┐
   196                                  ; │ More than three inputs handler                         │
   197                                  ; └────────────────────────────────────────────────────────┘
   198                                  more_than_three:
   199 00000219 B800000000                  mov     rax, 0
   200 0000021E 48BF-                       mov     rdi, three_inputs
   200 00000220 [2301000000000000] 
   201 00000228 E8(00000000)                call    printf
   202 0000022D E9BA000000                  jmp     exit
   203                                  
   204                                  ; ┌────────────────────────────────────────────────────────┐
   205                                  ; │ Input handling function                                │
   206                                  ; └────────────────────────────────────────────────────────┘
   207                                  input_array:
   208                                      back_register
    87 00000232 55                  <1>  push rbp
    88 00000233 4889E5              <1>  mov rbp, rsp
    89                              <1> 
    90                              <1> 
    91 00000236 53                  <1>  push rbx
    92 00000237 51                  <1>  push rcx
    93 00000238 52                  <1>  push rdx
    94 00000239 56                  <1>  push rsi
    95 0000023A 57                  <1>  push rdi
    96 0000023B 4150                <1>  push r8
    97 0000023D 4151                <1>  push r9
    98 0000023F 4152                <1>  push r10
    99 00000241 4153                <1>  push r11
   100 00000243 4154                <1>  push r12
   101 00000245 4155                <1>  push r13
   102 00000247 4156                <1>  push r14
   103 00000249 4157                <1>  push r15
   104 0000024B 9C                  <1>  pushf
   209                                      backup_compnents storedata
   107                              <1> 
   108 0000024C B807000000          <1>  mov rax,7
   109 00000251 BA00000000          <1>  mov rdx,0
   110 00000256 0FAE2425[00000000]  <1>  xsave [%1]
   210                                  
   211 0000025E 4989FD                      mov     r13, rdi 
   212 00000261 4989F6                      mov     r14, rsi     
   213 00000264 41BF00000000                mov     r15, 0 
   214 0000026A 4881EC00040000              sub     rsp, 1024   
   215                                  
   216                                  begin:
   217                                      ; ┌────────────────────────────────────────────────────────┐
   218                                      ; │ Use fgets to get user input                            │
   219                                      ; └────────────────────────────────────────────────────────┘
   220 00000271 B800000000                  mov     rax, 0
   221 00000276 4889E7                      mov     rdi, rsp
   222 00000279 BE00020000                  mov     rsi, 512
   223 0000027E 488B1425[00000000]          mov     rdx, [stdin]
   224 00000286 E8(00000000)                call    fgets
   225                                      ; ┌────────────────────────────────────────────────────────┐
   226                                      ; │ Check if user pressed Control+D                        │
   227                                      ; └────────────────────────────────────────────────────────┘
   228 0000028B 4898                        cdqe
   229 0000028D 4883F800                    cmp     rax, 0
   230 00000291 7459                        je      exit
   231                                      ; ┌────────────────────────────────────────────────────────┐
   232                                      ; │ Get rid of newline character after every line          │
   233                                      ; └────────────────────────────────────────────────────────┘
   234 00000293 4889E7                      mov     rdi, rsp
   235 00000296 E8(00000000)                call    strlen
   236 0000029B 4889C3                      mov     rbx, rax
   237 0000029E 48FFCB                      dec     rbx
   238                                  
   239 000002A1 C6041F00                    mov     byte [rdi + rbx], 0x00
   240                                  
   241                                      ; ┌────────────────────────────────────────────────────────┐
   242                                      ; │ Check if the input is a valid float                    │
   243                                      ; └────────────────────────────────────────────────────────┘
   244 000002A5 B800000000                  mov     rax, 0
   245 000002AA 4889E7                      mov     rdi, rsp
   246 000002AD E8A3000000                  call    isfloat
   247 000002B2 4883F800                    cmp     rax, 0
   248 000002B6 741E                        je      tryagain
   249                                  
   250                                      ; ┌────────────────────────────────────────────────────────┐
   251                                      ; │ Convert input into a float using atof                  │
   252                                      ; └────────────────────────────────────────────────────────┘
   253 000002B8 B800000000                  mov     rax, 0
   254 000002BD 4889E7                      mov     rdi, rsp
   255 000002C0 E8(00000000)                call    atof
   256                                       ; Copy the float into the array
   257 000002C5 F2430F1144FD00              movsd   [r13 + r15 * 8], xmm0
   258                                  
   259                                      ; Increase r15, repeat the loop if r15 is less than the max size
   260 000002CC 49FFC7                      inc     r15
   261 000002CF 4D39F7                      cmp     r15, r14
   262 000002D2 7C9D                        jl      begin
   263                                  
   264                                      ; Jump to exit otherwise
   265 000002D4 EB16                        jmp     exit  
   266                                  
   267                                  tryagain:
   268 000002D6 B800000000                  mov     rax, 0
   269 000002DB 48BF-                       mov     rdi, prompt_tryagain
   269 000002DD [0C01000000000000] 
   270 000002E5 E8(00000000)                call    printf
   271 000002EA EB85                        jmp     begin
   272                                  
   273                                  exit:
   274 000002EC 4881C400040000              add     rsp, 1024
   275                                      restore_components storedata
   113 000002F3 B807000000          <1>  mov rax,7
   114 000002F8 BA00000000          <1>  mov rdx,0
   115 000002FD 0FAE2C25[00000000]  <1>  xrstor [%1]
   276 00000305 4C89F8                      mov     rax, r15
   277                                      restore_registers
   123 00000308 9D                  <1>  popf
   124 00000309 415F                <1>  pop r15
   125 0000030B 415E                <1>  pop r14
   126 0000030D 415D                <1>  pop r13
   127 0000030F 415C                <1>  pop r12
   128 00000311 415B                <1>  pop r11
   129 00000313 415A                <1>  pop r10
   130 00000315 4159                <1>  pop r9
   131 00000317 4158                <1>  pop r8
   132 00000319 5F                  <1>  pop rdi
   133 0000031A 5E                  <1>  pop rsi
   134 0000031B 5A                  <1>  pop rdx
   135 0000031C 59                  <1>  pop rcx
   136 0000031D 5B                  <1>  pop rbx
   137                              <1> 
   138                              <1> 
   139 0000031E 5D                  <1>  pop rbp
   278 0000031F C3                          ret
   279                                  
   280                                  ; ┌────────────────────────────────────────────────────────┐
   281                                  ; │ No valid triangle handler                             │
   282                                  ; └────────────────────────────────────────────────────────┘
   283                                  no_triangle:
   284 00000320 B800000000                  mov     rax, 0
   285 00000325 48BF-                       mov     rdi, invalid
   285 00000327 [7301000000000000] 
   286 0000032F E8(00000000)                call    printf
   287 00000334 F20F100425-                 movsd   xmm0, [negative_one]
   287 00000339 [D7010000]         
   288                                      restore_registers
   123 0000033D 9D                  <1>  popf
   124 0000033E 415F                <1>  pop r15
   125 00000340 415E                <1>  pop r14
   126 00000342 415D                <1>  pop r13
   127 00000344 415C                <1>  pop r12
   128 00000346 415B                <1>  pop r11
   129 00000348 415A                <1>  pop r10
   130 0000034A 4159                <1>  pop r9
   131 0000034C 4158                <1>  pop r8
   132 0000034E 5F                  <1>  pop rdi
   133 0000034F 5E                  <1>  pop rsi
   134 00000350 5A                  <1>  pop rdx
   135 00000351 59                  <1>  pop rcx
   136 00000352 5B                  <1>  pop rbx
   137                              <1> 
   138                              <1> 
   139 00000353 5D                  <1>  pop rbp
   289 00000354 C3                          ret
   290                                  ;****************************************************************************************************************************
   291                                  ;Program name: "isfloat".  This a library function contained in a single file.  The function receives a null-terminated     *
   292                                  ;array of char and either verifies that the array can be converted to a 64-bit float or denies that such a conversion is    *
   293                                  ;possible.  Copyright (C) 2022 Floyd Holliday.                                                                              *
   294                                  ;                                                                                                                           *
   295                                  ;This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public   *
   296                                  ;License version 3 as published by the Free Software Foundation.  This program is distributed in the hope that it will be   *
   297                                  ;useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.*
   298                                  ;See the GNU Lesser General Public License for more details. A copy of the GNU General Public License v3 is available here: *
   299                                  ;<https:;www.gnu.org/licenses/>.                            *
   300                                  ;****************************************************************************************************************************
   301                                  ;
   302                                  ;
   303                                  ;========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1=========2=========3**
   304                                  ;Author information
   305                                  ;  Author name: Floyd Holliday
   306                                  ;  Author email: holliday@fullerton.edu
   307                                  ;  Author phone (wired phone in CS building): (657)278-7021
   308                                  ;
   309                                  ;Status
   310                                  ;  This software is not an application program, but rather it is a single function licensed for use by other applications.
   311                                  ;  This function can be embedded within both FOSS programs and in proprietary programs as permitted by the LGPL.
   312                                  
   313                                  ;Function information
   314                                  ;  Function name: isfloat
   315                                  ;  Programming language: X86 assembly in Intel syntax.
   316                                  ;  Date development began:  2022-Feb-28
   317                                  ;  Date version 1.0 finished: 2022-Mar-03
   318                                  ;  Files of this function: isfloat.asm
   319                                  ;  System requirements: an X86 platform with nasm installed o other compatible assembler.
   320                                  ;  Know issues: <now in testing phase>
   321                                  ;  Assembler used for testing: Nasm version 2.14.02
   322                                  ;  Prototype: bool isfloat(char *);
   323                                  ;
   324                                  ;Purpose
   325                                  ;  This function wil accept a string (array of char) and verify that it can be converted to a corresponding 64-bit 
   326                                  ;  float number or not converted to a float number.
   327                                  ;
   328                                  ;Translation information
   329                                  ;  Assemble: nasm -f elf64 -l isfloat.lis -o isfloat.o isfloat.asm
   330                                  ;
   331                                  ;Software design document:
   332                                  ;  An Execution flow chart accompanies this function.  That document will provide a better understanding of the 
   333                                  ;  algorithm used in the isfloat function than a direct reading of the source code of the function.
   334                                  
   335                                  ;========= Begin source code ====================================================================================
   336                                  ;Declaration area
   337                                  
   338                                  global isfloat
   339                                  
   340                                  null equ 0
   341                                  true equ -1
   342                                  false equ 0
   343                                  
   344                                  segment .data
   345                                     ;This segment is empty
   346                                  
   347                                  segment .bss
   348                                     ;This segment is empty
   349                                  
   350                                  segment .text
   351                                  isfloat:
   352                                  
   353                                  ;Block that backs up almost all GPRs
   354                                  ;Back up the general purpose registers for the sole purpose of protecting the data of the caller.
   355 00000355 55                      push rbp                                          ;Backup rbp
   356 00000356 4889E5                  mov  rbp,rsp                                      ;The base pointer now points to top of stack
   357 00000359 57                      push rdi                                          ;Backup rdi
   358 0000035A 56                      push rsi                                          ;Backup rsi
   359 0000035B 52                      push rdx                                          ;Backup rdx
   360 0000035C 51                      push rcx                                          ;Backup rcx
   361 0000035D 4150                    push r8                                           ;Backup r8
   362 0000035F 4151                    push r9                                           ;Backup r9
   363 00000361 4152                    push r10                                          ;Backup r10
   364 00000363 4153                    push r11                                          ;Backup r11
   365 00000365 4154                    push r12                                          ;Backup r12
   366 00000367 4155                    push r13                                          ;Backup r13
   367 00000369 4156                    push r14                                          ;Backup r14
   368 0000036B 4157                    push r15                                          ;Backup r15
   369 0000036D 53                      push rbx                                          ;Backup rbx
   370 0000036E 9C                      pushf                                             ;Backup rflags
   371                                  
   372                                  
   373                                  ;Make a copy of the passed in array of ascii values
   374 0000036F 4989FD                  mov r13, rdi                                      ;r13 is the array of char
   375                                  
   376                                  ;Let r14 be an index of the array r13.  Initialize to integer 0
   377 00000372 4D31F6                  xor r14, r14
   378                                  
   379                                  ;Check for leading plus or minus signs
   380 00000375 41807D002B              cmp byte [r13],'+'
   381 0000037A 7407                    je increment_index
   382 0000037C 41807D002D              cmp byte[r13],'-'
   383 00000381 7503                    jne continue_validation
   384                                  increment_index:
   385 00000383 49FFC6                  inc r14
   386                                  
   387                                  continue_validation:
   388                                  
   389                                  ;Block: loop to validate chars before the decimal point
   390                                  loop_before_point:
   391 00000386 B800000000                 mov rax,0
   392 0000038B 4831FF                     xor rdi,rdi                ;Zero out rdi
   393 0000038E 438A7C3500                 mov dil,byte [r13+1*r14]   ;dil is the low byte in the register rdi; reference Jorgensen, p. 10
   394 00000393 E85C000000                 call is_digit
   395 00000398 4883F800                   cmp rax,false
   396 0000039C 7405                       je is_it_radix_point
   397 0000039E 49FFC6                     inc r14
   398 000003A1 EBE3                       jmp loop_before_point
   399                                  ;End of loop checking chars before the point is encountered.
   400                                  
   401                                  is_it_radix_point:
   402                                  
   403                                  ;Is the next value of the array a genuine radix point?
   404 000003A3 43807C35002E            cmp byte[r13+1*r14],'.'
   405 000003A9 752C                        jne return_false
   406                                  
   407                                  ;A point has been found, therefore, begin a loop to process remaining digits.
   408                                  start_loop_after_finding_a_point:
   409 000003AB 49FFC6                      inc r14
   410 000003AE B800000000                  mov rax,0
   411 000003B3 4831FF                      xor rdi,rdi
   412 000003B6 438A7C3500                  mov dil,byte[r13+1*r14]
   413 000003BB E834000000                  call is_digit
   414 000003C0 4883F800                    cmp rax,false
   415 000003C4 75E5                        jne start_loop_after_finding_a_point
   416                                  ;End of loop processing valid digits after passing the one decimal point.
   417                                  
   418                                  ;Something other than a digit has been found.  
   419                                  ;It should be null at the end of the string.
   420 000003C6 43807C350000            cmp byte [r13+1*r14],null
   421 000003CC 7509                    jne return_false
   422 000003CE 48C7C0FFFFFFFF          mov rax,true
   423 000003D5 EB05                    jmp restore_gpr_registers
   424                                      
   425                                  return_false:
   426 000003D7 B800000000              mov rax,false
   427                                  
   428                                  restore_gpr_registers:
   429 000003DC 9D                      popf                                    ;Restore rflags
   430 000003DD 5B                      pop rbx                                 ;Restore rbx
   431 000003DE 415F                    pop r15                                 ;Restore r15
   432 000003E0 415E                    pop r14                                 ;Restore r14
   433 000003E2 415D                    pop r13                                 ;Restore r13
   434 000003E4 415C                    pop r12                                 ;Restore r12
   435 000003E6 415B                    pop r11                                 ;Restore r11
   436 000003E8 415A                    pop r10                                 ;Restore r10
   437 000003EA 4159                    pop r9                                  ;Restore r9
   438 000003EC 4158                    pop r8                                  ;Restore r8
   439 000003EE 59                      pop rcx                                 ;Restore rcx
   440 000003EF 5A                      pop rdx                                 ;Restore rdx
   441 000003F0 5E                      pop rsi                                 ;Restore rsi
   442 000003F1 5F                      pop rdi                                 ;Restore rdi
   443 000003F2 5D                      pop rbp                                 ;Restore rbp
   444                                  
   445 000003F3 C3                      ret                                     ;Pop the integer stack and jump to the address represented by the popped value.
   446                                  
   447                                  
   448                                  
   449                                  
   450                                  
   451                                  
   452                                  
   453                                  
   454                                  
   455                                  
   456                                  
   457                                  ;========= Begin function is_digit ==================================================================================
   458                                  
   459                                  ;****************************************************************************************************************************
   460                                  ;Program name: "is_digit".  This a library function contained in a single file.  The function receives a char parameter.  It*
   461                                  ;returns true if that parameter is the ascii value of a decimal digit and returns false in all other cases.                  *
   462                                  ;Copyright (C) 2022 Floyd Holliday.                                                                                         *
   463                                  ;                                                                                                                           *
   464                                  ;This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public   *
   465                                  ;License version 3 as published by the Free Software Foundation.  This program is distributed in the hope that it will be   *
   466                                  ;useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.*
   467                                  ;See the GNU Lesser General Public License for more details. A copy of the GNU General Public License v3 is available here: *
   468                                  ;<https:;www.gnu.org/licenses/>.                                                                                            *
   469                                  ;****************************************************************************************************************************
   470                                  ;
   471                                  ;
   472                                  ;========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1=========2=========3**
   473                                  ;Author information
   474                                  ;  Author name: Floyd Holliday
   475                                  ;  Author email: holliday@fullerton.edu
   476                                  ;  Author phone (wired phone in CS building): (657)278-7021
   477                                  ;
   478                                  ;Status
   479                                  ;  This software is not an application program, but rather it is a single function licensed for use by other applications.
   480                                  ;  This function can be embedded within both FOSS programs and in proprietary programs as permitted by the LGPL.
   481                                  
   482                                  ;Function information
   483                                  ;  Function name: is_digit
   484                                  ;  Name selection.  This function is named is_digit to avoid confusion with an existing library function named isdigit.
   485                                  ;  Programming language: X86 assembly in Intel syntax.
   486                                  ;  Date development began:  2022-Feb-28
   487                                  ;  Date version 1.0 finished: 2022-Feb 28
   488                                  ;  Files of this function: currently is_digit is an auxillary function of isfloat, and as such does not occupy its own file.
   489                                  ;  System requirements: an X86 platform with nasm installed or other compatible assembler.
   490                                  ;  Known issues: none
   491                                  ;  Assembler used for testing: Nasm version 2.14.02
   492                                  ;  Prototype: bool is_digit(char);
   493                                  ;
   494                                  ;Purpose
   495                                  ;  This function wil accept a single char as input parameter and determine if that parameter represents a decimal digit. 
   496                                  ;
   497                                  ;Translation information if this function occupied its own file.  Currently the function is_digit resides in the same 
   498                                  ;same file as isfloat and therefore, will be assembled when isfloat is assembled.
   499                                  ;  Assemble: nasm -f elf64 -l is_digit.lis -o is_digit.o is_digit.asm
   500                                  ;
   501                                  ;Software design document:
   502                                  ;  An Execution flow chart accompanies this function.  That document will provide a better understanding of the 
   503                                  ;  algorithm used in the isfloat function than a direct reading of the source code of the function.
   504                                  
   505                                  ;========= Begin source code ====================================================================================
   506                                  ;Declaration area
   507                                  true equ -1
   508                                  false equ 0
   509                                  ascii_value_of_zero equ 0x30
   510                                  ascii_value_of_nine equ 0x39
   511                                  
   512                                  segment .data
   513                                     ;This segment is empty
   514                                  
   515                                  segment .bss
   516                                     ;This segment is empty
   517                                  
   518                                  segment .text
   519                                  is_digit:
   520                                  
   521                                  ;Block that backs up almost all GPRs
   522                                  ;Back up the general purpose registers for the sole purpose of protecting the data of the caller.
   523 000003F4 55                      push rbp                                          ;Backup rbp
   524 000003F5 4889E5                  mov  rbp,rsp                                      ;The base pointer now points to top of stack
   525 000003F8 57                      push rdi                                          ;Backup rdi
   526 000003F9 56                      push rsi                                          ;Backup rsi
   527 000003FA 52                      push rdx                                          ;Backup rdx
   528 000003FB 51                      push rcx                                          ;Backup rcx
   529 000003FC 4150                    push r8                                           ;Backup r8
   530 000003FE 4151                    push r9                                           ;Backup r9
   531 00000400 4152                    push r10                                          ;Backup r10
   532 00000402 4153                    push r11                                          ;Backup r11
   533 00000404 4154                    push r12                                          ;Backup r12
   534 00000406 4155                    push r13                                          ;Backup r13
   535 00000408 4156                    push r14                                          ;Backup r14
   536 0000040A 4157                    push r15                                          ;Backup r15
   537 0000040C 53                      push rbx                                          ;Backup rbx
   538 0000040D 9C                      pushf                                             ;Backup rflags
   539                                  
   540                                  ;Make a copy of the passed in array of ascii values.
   541                                  ;Note that only the low one-byte of rdi is important for this function is_digit.
   542                                  ;Nevertheless, we copy the entire 8-byte register.
   543 0000040E 41BD00000000            mov r13,0
   544 00000414 4188FD                  mov r13b,dil     ;Copy the low byte of rdi to the low byte of r13.  The other bytes of rdi are all zeros.
   545                                  
   546                                  ;Block to test if value in r13 >= ascii(0)
   547 00000417 4983FD30                cmp r13,ascii_value_of_zero
   548 0000041B 7C12                    jl is_digit.return_false
   549                                  
   550                                  ;Block to test if value in r13 <= ascii(9)
   551 0000041D 4983FD39                cmp r13,ascii_value_of_nine
   552 00000421 7F0C                    jg is_digit.return_false
   553                                  
   554                                  ;Return true
   555 00000423 4831C0                  xor rax,rax  ;Set rax to zero
   556 00000426 48C7C0FFFFFFFF          mov rax,true
   557 0000042D EB08                    jmp is_digit.restore_gpr_registers
   558                                  
   559                                  is_digit.return_false:
   560 0000042F 4831C0                  xor rax,rax  ;Set rax to zero
   561 00000432 B800000000              mov rax,false
   562                                  
   563                                  is_digit.restore_gpr_registers:
   564                                  ;Restore all general purpose registers to their original values
   565 00000437 9D                      popf                                    ;Restore rflags
   566 00000438 5B                      pop rbx                                 ;Restore rbx
   567 00000439 415F                    pop r15                                 ;Restore r15
   568 0000043B 415E                    pop r14                                 ;Restore r14
   569 0000043D 415D                    pop r13                                 ;Restore r13
   570 0000043F 415C                    pop r12                                 ;Restore r12
   571 00000441 415B                    pop r11                                 ;Restore r11
   572 00000443 415A                    pop r10                                 ;Restore r10
   573 00000445 4159                    pop r9                                  ;Restore r9
   574 00000447 4158                    pop r8                                  ;Restore r8
   575 00000449 59                      pop rcx                                 ;Restore rcx
   576 0000044A 5A                      pop rdx                                 ;Restore rdx
   577 0000044B 5E                      pop rsi                                 ;Restore rsi
   578 0000044C 5F                      pop rdi                                 ;Restore rdi
   579 0000044D 5D                      pop rbp                                 ;Restore rbp
   580                                  
   581 0000044E C3                      ret                                     ;Pop the integer stack and jump to the address represented by the popped value.
